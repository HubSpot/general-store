/**
 * Flowtype definitions for general-store
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.10.0
 * @flow
 */

declare module "general-store" {
  import typeof * as DispatcherInstance from "general-store/dispatcher/DispatcherInstance";

  import typeof * as InspectStore from "general-store/store/InspectStore";

  import typeof StoreSingleton from "general-store/store/StoreSingleton";

  import typeof StoreFactory from "general-store/store/StoreFactory";

  declare export function define<T>(): StoreSingleton<T>;

  declare export function defineFactory<T>(): StoreFactory<T>;

  declare export { default as connect } from "general-store/dependencies/connect";

  declare export { default as connectCallback } from "general-store/dependencies/connectCallback";

  declare export { default as useStoreDependency } from "general-store/dependencies/useStoreDependency";

  declare export { DispatcherInstance, InspectStore };
}

declare module "general-store/dispatcher/DispatcherInstance" {
  import type { Dispatcher } from "flux";

  declare export function get(): Dispatcher<any> | null;

  declare export function set(dispatcher: Dispatcher<any>): void;

  declare export function clear(): Dispatcher<any>;
}

declare module "general-store/store/InspectStore" {
  import type { Dispatcher } from "flux";

  import type { StoreResponses } from "general-store/store/Store";

  import typeof StoreFactory from "general-store/store/StoreFactory";

  import typeof Store from "general-store/store/Store";

  declare export function getActionTypes(store: Store<any>): Array<string>;

  declare export function getDispatcher(store: Store<any>): Dispatcher<any>;

  declare export function getDispatchToken(store: Store<any>): string;

  declare export function getGetter<T>(
    store: Store<T>
  ): (...args: Array<any>) => T;

  declare export function getId(store: Store<any>): string;

  declare export function getFactory<T>(store: Store<T>): StoreFactory<T>;

  declare export function getName(store: Store<any>): string;

  declare export function getResponses(store: Store<any>): StoreResponses<any>;

  declare export function getState<T>(store: Store<T>): T;

  declare export function isStore(store: any): boolean;
}

declare module "general-store/store/StoreSingleton" {
  import type { Dispatcher } from "flux";

  import typeof Store from "general-store/store/Store";

  import typeof StoreFactory from "general-store/store/StoreFactory";

  declare export default class StoreSingleton<T> {
    _facade?: Store<T>;
    _factory: StoreFactory<T>;
    _getter?: Function;
    constructor(): this;
    defineGet(getter: () => any): StoreSingleton<T>;
    defineName(name: string): StoreSingleton<T>;
    defineResponseTo(
      actionTypes: Array<string> | string,
      response: (data: any) => void
    ): StoreSingleton<T>;
    isRegistered(): boolean;
    register(dispatcher?: Dispatcher<any>): Store<T>;
  }
}

declare module "general-store/store/StoreFactory" {
  import type { Dispatcher } from "flux";

  import type Store, {
    StoreGetter,
    StoreResponses,
    StoreResponse
  } from "general-store/store/Store";

  declare type StoreFactoryDefinition<T> = {
    getter?: StoreGetter<T>,
    getInitialState?: StoreGetter<T>,
    name?: string,
    responses?: StoreResponses<T>
  };
  declare export default class StoreFactory<T> {
    _definition: StoreFactoryDefinition<T>;
    constructor(x?: StoreFactoryDefinition<T>): this;
    defineGet(getter: StoreGetter<T>): StoreFactory<T>;
    defineGetInitialState(getInitialState: StoreGetter<T>): StoreFactory<T>;
    defineName(name: string): StoreFactory<T>;
    defineResponses(newResponses: StoreResponses<T>): StoreFactory<T>;
    defineResponseTo(
      actionTypes: string | Array<string>,
      response: StoreResponse<T>
    ): StoreFactory<T>;
    getDefinition(): StoreFactoryDefinition<T>;
    register(dispatcher?: Dispatcher<any>): Store<T>;
  }
  declare export {};
}

declare module "general-store/dependencies/connect" {
  import type {
    DependencyMap,
    DependencyMapProps
  } from "general-store/dependencies/DependencyMap";

  import type { Dispatcher } from "flux";

  import typeof * as React from "react";

  import type { RefObject } from "react";

  declare export function useCurrent<ValueType>(
    value: ValueType
  ): RefObject<ValueType>;

  declare export default function connect<Deps: DependencyMap>(
    dependencies: Deps,
    dispatcher?: Dispatcher<any>
  ): <C: any, Props: DependencyMapProps<Deps>>(
    BaseComponent: React.ComponentType<Props>
  ) => any;
}

declare module "general-store/dependencies/connectCallback" {
  import type { DependencyMap } from "general-store/dependencies/DependencyMap";

  import type { Dispatcher } from "flux";

  declare export default function connectCallback(
    dependencies: DependencyMap,
    dispatcher?: Dispatcher<any>
  ): any;
}

declare module "general-store/dependencies/useStoreDependency" {
  import type { Dispatch, RefObject, SetStateAction } from "react";

  import type {
    Dependency,
    DependencyMap,
    GetDependencyType
  } from "general-store/dependencies/DependencyMap";

  import type { Dispatcher } from "flux";

  declare export function useCurrent<ValueType>(
    value: ValueType
  ): RefObject<ValueType>;

  declare export function _useDispatchSubscription<
    Props,
    DependencyMapType: DependencyMap,
    DependenciesType
  >(
    dependencyMap: DependencyMapType,
    currentProps: RefObject<Props>,
    dispatcher: Dispatcher<any>,
    dependencyValue: DependenciesType,
    setDependencyValue: Dispatch<SetStateAction<DependenciesType>>
  ): void;

  declare function useStoreDependency<Props, DepType>(
    dependency: Dependency<DepType>,
    props?: Props,
    dispatcher?: Dispatcher<any>
  ): DepType;

  declare export default typeof useStoreDependency;
}

declare module "general-store/store/Store" {
  import type { Dispatcher } from "flux";

  import typeof StoreFactory from "general-store/store/StoreFactory";

  import typeof Event from "general-store/event/Event";

  import typeof EventHandler from "general-store/event/EventHandler";

  /* 
    declare module 'global' {
      declare interface Window {
__REDUX_DEVTOOLS_EXTENSION__: DevToolsExtension,
} 
    }
     */

  declare export type Action = {
    actionType: string,
    type: string,
    data: any,
    payload: any
  };
  declare export type StoreGetter<T> = (...args: Array<any>) => T;
  declare export type StoreResponse<T> = (
    state: T,
    data: any,
    actionType: string,
    payload: Action
  ) => any;
  declare export type StoreResponses<T> = {
    [key: string]: StoreResponse<T>
  };
  declare type StoreOptions<T> = {
    dispatcher: Dispatcher<any>,
    factory: StoreFactory<T>,
    getter: StoreGetter<T>,
    initialState: T,
    name?: string,
    responses: StoreResponses<T>
  };
  declare type DevToolsOptions = {
    name: string,
    instanceId: string
  };
  declare type DevToolsMessage = {
    type: string,
    state: any,
    payload: DevToolsMessage
  };
  declare type DevToolsExtension = {
    connect: (options: DevToolsOptions) => DevToolsExtension,
    send: (message: string, data: any) => any,
    unsubscribe: () => any,
    subscribe: (callback: (message: DevToolsMessage) => void) => any
  };
  declare export default class Store<T> {
    _dispatcher: Dispatcher<any>;
    _dispatchToken: string;
    _factory: StoreFactory<T>;
    _getter: StoreGetter<T>;
    _event: Event;
    _name: string;
    _responses: StoreResponses<T>;
    _state: any;
    _uid: string;
    _devToolsExtension: DevToolsExtension;
    _unsubscribeDevTools?: () => any;
    constructor(x: StoreOptions<T>): this;

    /**
     * Subscribe to changes on this store.
     * @param callback will run every time the store responds to a dispatcher
     * @return this
     */
    addOnChange(callback: Function): EventHandler;

    /**
     * Returns the store's referenced value
     * @param ...accepts any number of params
     * @return any
     */
    get(...args: any[]): T;

    /**
     * @protected Responds to incoming messages from the Dispatcher
     */
    _handleDispatch(payload: Action): void;

    /**
     * Destroys this instance of the store.
     * Dispatch callback is unregistered. Subscriptions are removed.
     */
    remove(): void;
    toString(): string;

    /**
     * Runs all of the store's subscription callbacks
     * @return this
     */
    triggerChange(): Store<T>;
  }
  declare export {};
}

declare module "general-store/dependencies/DependencyMap" {
  import type { ComponentType } from "react";

  import typeof Store from "general-store/store/Store";

  import typeof hoistStatics from "hoist-non-react-statics";

  declare export type CompoundDependency<T> = {
    propTypes?: Object,
    stores: Store<any>[],
    deref: (props?: Object, state?: Object, stores?: Store<any>[]) => T
  };
  declare export type Dependency<T> = CompoundDependency<T> | Store<T>;
  declare export type DependencyIndexEntry = {
    dispatchTokens: {
      [key: string]: boolean
    },
    fields: {
      [key: string]: boolean
    }
  };
  declare export type DependencyIndex = {
    [key: string]: DependencyIndexEntry
  };
  declare export type DependencyMap = {
    [key: string]: Dependency<any>
  };
  declare export type GetProps<
    C
  > = /* Flow doesn't support conditional types, use `$Call` utility type */ any;
  declare export type GetDependencyType<
    D
  > = /* Flow doesn't support conditional types, use `$Call` utility type */ any;
  declare export type DependencyMapProps<
    DM: DependencyMap
  > = /* Flow doesn't support conditional types, use `$Call` utility type */ any;
  declare export type ConnectedComponentType<
    P,
    C
  > = React$ForwardRefExoticComponent<P & C> & {
    WrappedComponent: C,
    dependencies: DependencyMap
  } & hoistStatics.NonReactStatics<P & C>;
  declare export type PropTypes = {
    [key: string]: Function
  };
  declare export function enforceValidDependencies(
    dependencies: DependencyMap
  ): DependencyMap;

  declare export function dependencyPropTypes(
    dependencies: DependencyMap,
    existingPropTypes?: {
      [key: string]: Function
    }
  ): PropTypes;

  declare export function calculate<Props, State, DerefValue>(
    dependency: Dependency<DerefValue>,
    props?: Props,
    state?: State
  ): DerefValue;

  declare export function calculateInitial<Props, State, Deps: DependencyMap>(
    dependencies: Deps,
    props: Props,
    state?: State
  ): $ObjMapi<Deps, <key>(key) => GetDependencyType<$ElementType<Deps, key>>>;

  declare export function calculateForDispatch<
    Props,
    State,
    Deps: DependencyMap
  >(
    dependencies: Deps,
    dependencyIndexEntry: DependencyIndexEntry,
    props: Props,
    state?: State
  ): $ObjMapi<Deps, <key>(key) => $ElementType<Deps, key>>;

  declare export function makeDependencyIndex(
    dependencies: DependencyMap
  ): DependencyIndex;
}

declare module "general-store/event/Event" {
  import typeof EventHandler from "general-store/event/EventHandler";

  declare export default class Event {
    _handlers: {
      [key: string]: Function
    };
    constructor(): this;

    /**
     * Add a subscription to this event
     * @param callback run when the event is triggered.
     * @return this
     */
    addHandler(callback: Function): EventHandler;

    /**
     * Destroys this event. Removes all handlers.
     * @return this
     */
    remove(): Event;

    /**
     * Removes a subscription by key.
     * @param key id of the subscription to remove
     * @return this
     */
    removeHandler(key: string): Event;

    /**
     * @protected Run a handler by key if it exists
     * @param key id of the handler to run
     */
    _runHandler(key: string): void;

    /**
     * Run all subscribed handlers.
     * @return this
     */
    runHandlers(): Event;

    /**
     * Convenience method for running multiple events.
     * @param events a list of events to run.
     */
    static runMultiple(events: Array<Event>): void;
  }
}

declare module "general-store/event/EventHandler" {
  import typeof Event from "general-store/event/Event";

  declare export default class EventHandler {
    _key: string;
    _instance?: Event;
    constructor(instance: Event, key: string): this;
    getKey(): string;
    remove(): void;
  }
}
