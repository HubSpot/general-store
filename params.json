{"name":"General Store","tagline":"Simple, flexible store implementation for Flux. #hubspot-open-source","body":"![HubSpot/general-store](https://cloud.githubusercontent.com/assets/478109/6376307/1d3c77dc-bceb-11e4-9a96-0a909810cc69.png)\r\n\r\n[![NPM version](http://img.shields.io/npm/v/general-store.svg)](https://www.npmjs.com/package/general-store)\r\n[![Build Status](https://travis-ci.org/HubSpot/general-store.svg?branch=master)](https://travis-ci.org/HubSpot/general-store)\r\n\r\n**This is beta software. It's going to change.**\r\n\r\n`general-store` aims to provide all the features of a [Flux](http://facebook.github.io/flux/) store without prescribing the implementation of that store's data or mutations.\r\n\r\nBriefly, a store:\r\n\r\n1. contains any arbitrary value\r\n2. exposes that value via a get method\r\n3. responds to specific events from the dispatcher\r\n4. notifies subscribers when its value changes\r\n\r\nThat's it. All other features, like Immutability, data fetching, undo, etc. are implementation details.\r\n\r\nRead more about the `general-store` rationale [on the HubSpot Product Team Blog](http://product.hubspot.com/blog/keeping-flux-flexible-with-general-store).\r\n\r\n## Install\r\n\r\n```\r\n# for node, browserify, etc\r\nnpm install general-store\r\n\r\n# for bower\r\nbower install general-store\r\n```\r\n\r\n## Create a store\r\n\r\nGeneralStore uses functions to encapsulate private data.\r\n\r\n```javascript\r\nvar dispatcher = new Flux.Dispatcher();\r\nfunction defineUserStore() {\r\n  // data is stored privately inside the store module's closure\r\n  var users = {\r\n    123: {\r\n      id: 123,\r\n      name: 'Mary'\r\n    }\r\n  };\r\n\r\n  return GeneralStore.define()\r\n    // the store's getter should return the public subset of its data\r\n    .defineGet(function() {\r\n      return users;\r\n    })\r\n    // handle actions received from the dispatcher\r\n    .defineResponseTo('USER_ADDED', function(user) {\r\n      users[user.id] = user;\r\n    })\r\n    .defineResponseTo('USER_REMOVED', function(user) {\r\n      delete users[user.id];\r\n    })\r\n    // after a store is \"registered\" its action handlers are bound\r\n    // to the dispatcher\r\n    .register(dispatcher);\r\n}\r\n```\r\n\r\nIf you use a singleton pattern for stores, simply use the result of `register` from a module.\r\n\r\n```javascript\r\nvar Dispatcher = require('flux').Dispatcher;\r\nvar GeneralStore = require('general-store.js');\r\n\r\nvar dispatcher = new Dispatcher();\r\nvar users = {};\r\n\r\nvar UserStore = GeneralStore.define()\r\n  .defineGet(function() {\r\n    return users;\r\n  })\r\n  .register(dispatcher);\r\n\r\nmodule.exports = UserStore;\r\n```\r\n\r\n## Dispatch to the Store\r\n\r\nSending a message to your stores via the dispatcher is easy.\r\n\r\n```javascript\r\ndispatcher.dispatch({\r\n  actionType: 'USER_ADDED', // required field\r\n  data: { // optional field, passed to the store's response\r\n    id: 12314,\r\n    name: 'Colby Rabideau'\r\n  }\r\n});\r\n```\r\n\r\n## Store Factories\r\n\r\nThe classic singleton store API is great, but can be hard to test.\r\n`defineFactory()` provides an composable alternative to `define()` that makes\r\ntesting easier and allows you to extend store behavior.\r\n\r\n```javascript\r\nvar UserStoreFactory = GeneralStore.defineFactory()\r\n  .defineInitialState(function() {\r\n    return {};\r\n  })\r\n  .defineResponseTo({\r\n    USER_ADDED: function(state, user) {\r\n      state[user.id] = user;\r\n      return state;\r\n    },\r\n    USER_REMOVED: function(state, user) {\r\n      delete state[user.id];\r\n      return state;\r\n    },\r\n  });\r\n```\r\n\r\nLike singletons, factories have a register method. Unlike singletons, that\r\nregister method can be called many times and will always return a **new\r\ninstance** of the store described by the factory, which is useful in unit tests.\r\n\r\n```javascript\r\ndescribe('UserStore', () => {\r\n  var storeInstance;\r\n  beforeEach(() => {\r\n    // each test will have a clean store\r\n    storeInstance = UserStoreFactory.register(dispatcher);\r\n  });\r\n\r\n  it('adds users', () => {\r\n    var mockUser = {id: 1, name: 'Joe'};\r\n    dispatcher.dispatch({actionType: USER_ADDED, data: mockUser});\r\n    expect(storeInstance.get()).toEqual({1: mockUser});\r\n  });\r\n\r\n  it('removes users', () => {\r\n    var mockUser = {id: 1, name: 'Joe'};\r\n    dispatcher.dispatch({actionType: USER_ADDED, data: mockUser});\r\n    dispatcher.dispatch({actionType: USER_REMOVED, data: mockUser});\r\n    expect(storeInstance.get()).toEqual({});\r\n  });\r\n});\r\n```\r\n\r\n## Using the Store API\r\n\r\nA registered Store provides methods for \"getting\" its value and subscribing to changes to that value.\r\n\r\n```javascript\r\nUserStore.get() // returns {}\r\nvar subscription = UserStore.addOnChange(function() {\r\n  // handle changes!\r\n});\r\n// addOnChange returns an object with a `remove` method.\r\n// When you're ready to unsubscribe from a store's changes,\r\n// simply call that method.\r\nsubscription.remove();\r\n```\r\n\r\n## React\r\n\r\nGeneralStore provides a convenient mixin for binding stores to React components:\r\n\r\n```javascript\r\nvar ProfileComponent = React.createClass({\r\n  mixins: [\r\n    GeneralStore.StoreDependencyMixin({\r\n      // simple fields can be expressed in the form `key => store`\r\n      subject: ProfileStore,\r\n      // compound fields can depend on one or more stores\r\n      // and specify a function to \"dereference\" the store's value\r\n      friends: {\r\n        stores: [ProfileStore, UsersStore],\r\n        deref: (props, state) => {\r\n          friendIds = ProfileStore.get().friendIds;\r\n          users = UsersStore.get();\r\n          return friendIds.map(id => users[id]);\r\n        }\r\n      }\r\n    })\r\n  ],\r\n\r\n  render: function() {\r\n    return (\r\n      <div>\r\n        <h1>{this.state.subject.name}</h1>\r\n        {this.renderFriends()}\r\n      </div>\r\n    );\r\n  },\r\n\r\n  renderFriends: function() {\r\n    var friends = this.state.friends;\r\n    return (\r\n      <div>\r\n        <h3>Friends</h3>\r\n        <ul>\r\n          {Object.keys(friends).map(id => <li>{friends[id].name}</li>)}\r\n        </ul>\r\n      </div>\r\n    );\r\n  }\r\n});\r\n```\r\n\r\n## Default Dispatcher Instance\r\n\r\nThe common Flux architecture has a single central dispatcher. As a convenience `GeneralStore` allows you to set a global dispatcher which will become the default when a store is registered.\r\n\r\n```javascript\r\nvar dispatcher = new Flux.Dispatcher();\r\nGeneralStore.DispatcherInstance.set(dispatcher);\r\n```\r\n\r\nNow you can register a store without explicitly passing a dispatcher:\r\n\r\n```javascript\r\nvar users = {};\r\n\r\nGeneralStore.define()\r\n  .defineGet(() => users)\r\n  .register(); // the dispatcher instance is set so no need to explicitly pass it\r\n```\r\n\r\n## Dispatcher Interface\r\n\r\nAt HubSpot we use the [Facebook Dispatcher](https://github.com/facebook/flux), but any object that conforms to the same interface (i.e. has register and unregister methods) should work just fine.\r\n\r\n```javascript\r\ntype DispatcherPayload = {\r\n  actionType: string;\r\n  data: any;\r\n};\r\n\r\ntype Dispatcher = {\r\n  isDispatching: () => bool;\r\n  register: (\r\n    handleAction: (payload: DispatcherPayload) => void\r\n  ) => string;\r\n  unregister: (dispatchToken: string) => void;\r\n  waitFor: (dispatchTokens: Array<string>) => void;\r\n};\r\n```\r\n\r\n## Build and test\r\n\r\n**Install Dependencies**\r\n\r\n```\r\n# pull in dependencies\r\nnpm install\r\n\r\n# run the type checker and unit tests\r\nnpm test\r\n\r\n# if all tests pass, run the dev and prod build\r\nnpm run build-and-test\r\n\r\n# if all tests pass, run the dev and prod build then commit and push changes\r\nnpm run deploy\r\n```\r\n\r\n## Special Thanks\r\n\r\nLogo design by [Chelsea Bathurst](http://www.chelseabathurst.com)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}